// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: batch.go

package db

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const createFHRSRawData = `-- name: CreateFHRSRawData :batchexec
insert into fhrs_raw_data (
    fhrs_id,
    local_authority_business_id,
    business_name,
    business_type,
    business_type_id,
    address_line1,
    address_line2,
    address_line3,
    postcode,
    rating_value,
    rating_key,
    rating_date,
    local_authority_code,
    local_authority_name,
    local_authority_website,
    local_authority_email,
    scheme_type,
    new_rating_pending,
    longitude,
    latitude
  )
values (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16,
    $17,
    $18,
    $19,
    $20
  ) on conflict (fhrs_id) do
update
set local_authority_business_id = excluded.local_authority_business_id,
  business_name = excluded.business_name,
  business_type = excluded.business_type,
  business_type_id = excluded.business_type_id,
  address_line1 = excluded.address_line1,
  address_line2 = excluded.address_line2,
  address_line3 = excluded.address_line3,
  postcode = excluded.postcode,
  rating_value = excluded.rating_value,
  rating_key = excluded.rating_key,
  rating_date = excluded.rating_date,
  local_authority_code = excluded.local_authority_code,
  local_authority_name = excluded.local_authority_name,
  local_authority_website = excluded.local_authority_website,
  local_authority_email = excluded.local_authority_email,
  scheme_type = excluded.scheme_type,
  new_rating_pending = excluded.new_rating_pending,
  longitude = excluded.longitude,
  latitude = excluded.latitude
`

type CreateFHRSRawDataBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateFHRSRawDataParams struct {
	FhrsID                   int64         `json:"fhrs_id"`
	LocalAuthorityBusinessID pgtype.Text   `json:"local_authority_business_id"`
	BusinessName             pgtype.Text   `json:"business_name"`
	BusinessType             pgtype.Text   `json:"business_type"`
	BusinessTypeID           pgtype.Int4   `json:"business_type_id"`
	AddressLine1             pgtype.Text   `json:"address_line1"`
	AddressLine2             pgtype.Text   `json:"address_line2"`
	AddressLine3             pgtype.Text   `json:"address_line3"`
	Postcode                 pgtype.Text   `json:"postcode"`
	RatingValue              pgtype.Text   `json:"rating_value"`
	RatingKey                pgtype.Text   `json:"rating_key"`
	RatingDate               pgtype.Text   `json:"rating_date"`
	LocalAuthorityCode       pgtype.Int4   `json:"local_authority_code"`
	LocalAuthorityName       pgtype.Text   `json:"local_authority_name"`
	LocalAuthorityWebsite    pgtype.Text   `json:"local_authority_website"`
	LocalAuthorityEmail      pgtype.Text   `json:"local_authority_email"`
	SchemeType               pgtype.Text   `json:"scheme_type"`
	NewRatingPending         pgtype.Bool   `json:"new_rating_pending"`
	Longitude                pgtype.Float8 `json:"longitude"`
	Latitude                 pgtype.Float8 `json:"latitude"`
}

func (q *Queries) CreateFHRSRawData(ctx context.Context, arg []CreateFHRSRawDataParams) *CreateFHRSRawDataBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.FhrsID,
			a.LocalAuthorityBusinessID,
			a.BusinessName,
			a.BusinessType,
			a.BusinessTypeID,
			a.AddressLine1,
			a.AddressLine2,
			a.AddressLine3,
			a.Postcode,
			a.RatingValue,
			a.RatingKey,
			a.RatingDate,
			a.LocalAuthorityCode,
			a.LocalAuthorityName,
			a.LocalAuthorityWebsite,
			a.LocalAuthorityEmail,
			a.SchemeType,
			a.NewRatingPending,
			a.Longitude,
			a.Latitude,
		}
		batch.Queue(createFHRSRawData, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateFHRSRawDataBatchResults{br, len(arg), false}
}

func (b *CreateFHRSRawDataBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateFHRSRawDataBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
